package com.the_qa_company.qendpoint.core.iterator.utils;

import java.io.Closeable;
import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Objects;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.function.Function;

/**
 * a utility class to create an iterator from the value returned by another
 * Thread
 *
 * @param <T> the iterator type
 * @author Antoine Willerval
 */

public class PipedCopyIterator<T> implements Iterator<T>, Closeable {

	public static final int BATCH_SIZE = 1024;
	private static final int QUEUE_ELEMENT_CAPACITY = BATCH_SIZE * 16;

	/**
	 * RuntimeException generated by the PipedCopyIterator
	 *
	 * @author Antoine Willerval
	 */
	public static class PipedIteratorException extends RuntimeException {
		public PipedIteratorException(String message, Throwable t) {
			super(message, t);
		}
	}

	/**
	 * Callback for the
	 * {@link #createOfCallback(PipedCopyIterator.PipeCallBack)} method
	 *
	 * @param <T> the iterator type
	 * @author Antoine Willerval
	 */
	@FunctionalInterface
	public interface PipeCallBack<T> {
		/**
		 * method called from the new thread to generate the new data, at the
		 * end of the callback, the pipe is closed with or without exception
		 *
		 * @param pipe the pipe to fill
		 * @throws Exception any exception returned by the generator
		 */
		void createPipe(PipedCopyIterator<T> pipe) throws Exception;
	}

	/**
	 * create a piped iterator from a callback runner, the call to the callback
	 * should be made in the callbackRunner
	 *
	 * @param callbackRunner the callback runner
	 * @param <T>            type of the iterator
	 * @return the iterator
	 */
	public static <T> PipedCopyIterator<T> createOfCallback(PipeCallBack<T> callbackRunner) {
		PipedCopyIterator<T> pipe = new PipedCopyIterator<>();

		Thread thread = new Thread(() -> {
			try {
				callbackRunner.createPipe(pipe);
				pipe.closePipe();
			} catch (Throwable e) {
				pipe.closePipe(e);
			}
		}, "PipeIterator");
		thread.start();

		// close the thread at end
		pipe.attachThread(thread);

		return pipe;
	}

	private interface QueueObject<T> {
		boolean end();

		Object[] array();

		int size();
	}

	private static final class ElementQueueObject<T> implements QueueObject<T> {
		private final Object[] array;

		private ElementQueueObject(Object[] array, int size) {
			if (size < 0 || size > array.length) {
				throw new IllegalArgumentException("Illegal size " + size + " for array length " + array.length);
			}
			this.array = array;
			this.size = size;
		}

		private final int size;

		@Override
		public boolean end() {
			return false;
		}

		@Override
		public Object[] array() {
			return array;
		}

		@Override
		public int size() {
			return size;
		}
	}

	private static final class EndQueueObject<T> implements QueueObject<T> {
		@Override
		public boolean end() {
			return true;
		}

		@Override
		public Object[] array() {
			throw new IllegalArgumentException();
		}

		@Override
		public int size() {
			throw new IllegalArgumentException();
		}
	}

	private static int queueBatchCapacity(int batchSize) {
		int batches = Math.max(2, (QUEUE_ELEMENT_CAPACITY + batchSize - 1) / batchSize);
		return nextPowerOfTwo(batches);
	}

	private static int nextPowerOfTwo(int value) {
		int highestOneBit = Integer.highestOneBit(value);
		return value == highestOneBit ? value : highestOneBit << 1;
	}

	private final int batchSize;
	private final ArrayBlockingQueue<QueueObject<T>> queue;
	private final ArrayBlockingQueue<Object[]> recycledArrays;

	private Object[] readArray;
	private int readArrayIndex;
	private int readArraySize;

	private Object[] writeArray;
	private int writeArraySize;

	private boolean end;
	private PipedIteratorException exception;

	private Thread thread;

	@Override
	public boolean hasNext() {
		if (end) {
			return false;
		}
		if (readArray != null && readArrayIndex < readArraySize) {
			return true;
		}

		if (readArray != null) {
			recycleArray(readArray, readArraySize);
			readArray = null;
			readArrayIndex = 0;
			readArraySize = 0;
		}

		QueueObject<T> obj;
		try {
			obj = queue.take();
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			throw new PipedIteratorException("Can't read pipe", e);
		}

		if (obj.end()) {
			end = true;
			if (exception != null) {
				throw exception;
			}
			return false;
		}

		readArray = obj.array();
		readArraySize = obj.size();
		readArrayIndex = 0;
		return true;
	}

	@Override
	public T next() {
		if (!hasNext()) {
			return null;
		}
		@SuppressWarnings("unchecked")
		T next = (T) readArray[readArrayIndex];
		readArray[readArrayIndex] = null;
		readArrayIndex++;
		if (readArrayIndex >= readArraySize) {
			recycleArray(readArray, readArraySize);
			readArray = null;
			readArrayIndex = 0;
			readArraySize = 0;
		}
		return next;
	}

	/**
	 * Batch of elements transferred through the pipe.
	 * <p>
	 * Call {@link #close()} after consumption to return the underlying array to
	 * the producer for reuse.
	 */
	public static final class Batch<T> implements AutoCloseable {
		private final PipedCopyIterator<T> pipe;
		private Object[] array;
		private int size;

		private Batch(PipedCopyIterator<T> pipe, Object[] array, int size) {
			this.pipe = pipe;
			this.array = array;
			this.size = size;
		}

		public Object[] array() {
			return array;
		}

		public int size() {
			return size;
		}

		@Override
		public void close() {
			Object[] array = this.array;
			if (array == null) {
				return;
			}
			this.array = null;
			int size = this.size;
			this.size = 0;
			pipe.recycleArray(array, size);
		}
	}

	/**
	 * Borrow a reusable fixed-size {@code Object[]} buffer (length equals this
	 * pipe's batch size) for use with {@link #addBatch(Object[], int)}.
	 * <p>
	 * Intended for the single producer thread.
	 */
	public Object[] borrowArray() {
		Object[] array = recycledArrays.poll();
		if (array != null) {
			return array;
		}
		return new Object[batchSize];
	}

	/**
	 * Add a batch previously obtained via {@link #borrowArray()} to the pipe.
	 *
	 * @param array the array buffer (length equals this pipe's batch size)
	 * @param size  number of valid elements in {@code array}
	 */
	public void addBatch(Object[] array, int size) {
		Objects.requireNonNull(array, "array can't be null!");
		if (array.length != batchSize) {
			throw new IllegalArgumentException("array length must be " + batchSize + ", got " + array.length);
		}
		if (size <= 0 || size > batchSize) {
			throw new IllegalArgumentException("size must be between 1 and " + batchSize + ", got " + size);
		}

		// Flush any buffered elements to preserve ordering when mixing
		// addElement and addBatch.
		if (writeArraySize > 0) {
			flushWriteArray();
		}

		try {
			queue.put(new ElementQueueObject<>(array, size));
		} catch (InterruptedException ee) {
			Thread.currentThread().interrupt();
			throw new PipedIteratorException("Can't add batch to pipe", ee);
		}
	}

	public void closePipe() {
		closePipe(null);
	}

	public void closePipe(Throwable e) {
		if (writeArraySize > 0 && e == null) {
			flushWriteArray();
		} else {
			writeArray = null;
			writeArraySize = 0;
		}
		if (e != null) {
			queue.clear();
			if (e instanceof PipedIteratorException) {
				this.exception = (PipedIteratorException) e;
			} else {
				this.exception = new PipedIteratorException("closing exception", e);
			}
		}
		try {
			queue.put(new EndQueueObject<>());
		} catch (InterruptedException ee) {
			Thread.currentThread().interrupt();
			throw new PipedIteratorException("Can't close pipe", ee);
		}
	}

	/**
	 * map this iterator to another type
	 *
	 * @param mappingFunction the mapping function
	 * @param <E>             the future type
	 * @return mapped iterator
	 */
	public <E> Iterator<E> map(Function<T, E> mappingFunction) {
		return new MapIterator<>(this, mappingFunction);
	}

	/**
	 * map this iterator to another type
	 *
	 * @param mappingFunction the mapping function
	 * @param <E>             the future type
	 * @return mapped iterator
	 */
	public <E> Iterator<E> mapWithId(MapIterator.MapWithIdFunction<T, E> mappingFunction) {
		return new MapIterator<>(this, mappingFunction);
	}

	public void addElement(T node) {
		if (writeArray == null) {
			writeArray = borrowArray();
			writeArraySize = 0;
		}

		writeArray[writeArraySize] = node;
		writeArraySize++;

		if (writeArraySize >= batchSize) {
			flushWriteArray();
		}
	}

	public Batch<T> takeBatch() {
		if (end) {
			return null;
		}
		if (readArray != null && readArrayIndex < readArraySize) {
			throw new IllegalStateException("Can't takeBatch while iterating over elements");
		}

		QueueObject<T> obj;
		try {
			obj = queue.take();
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			throw new PipedIteratorException("Can't read pipe", e);
		}

		if (obj.end()) {
			end = true;
			if (exception != null) {
				throw exception;
			}
			return null;
		}

		return new Batch<>(this, obj.array(), obj.size());
	}

	private void flushWriteArray() {
		Object[] array = writeArray;
		int size = writeArraySize;
		writeArray = null;
		writeArraySize = 0;
		if (array == null || size <= 0) {
			return;
		}
		addBatch(array, size);
	}

	private void recycleArray(Object[] array, int size) {
		if (array == null) {
			return;
		}
		Arrays.fill(array, 0, Math.min(size, array.length), null);
		// Best effort: don't block if the recycle queue is full.
		recycledArrays.offer(array);
	}

	/**
	 * attach a thread to interrupt with this iterator
	 *
	 * @param thread the thread
	 */
	public void attachThread(Thread thread) {
		Objects.requireNonNull(thread, "thread can't be null!");
		if (this.thread != null && this.thread != thread) {
			throw new IllegalArgumentException("Thread already attached");
		}
		this.thread = thread;
	}

	/**
	 * Allow receiving again elements after an end node
	 */
	public void reset() {
		this.end = false;
//		if(queue1.peek().end()) queue1.poll();
//		if(queue2.peek().end()) queue2.poll();
	}

	@Override
	public void close() throws IOException {
		if (thread != null) {
			thread.interrupt();
		}
	}

	public PipedCopyIterator() {
		this(BATCH_SIZE);
	}

	public PipedCopyIterator(int batchSize) {
		if (batchSize <= 0) {
			throw new IllegalArgumentException("batchSize must be > 0");
		}
		this.batchSize = batchSize;
		int queueCapacity = queueBatchCapacity(batchSize);
		this.queue = new ArrayBlockingQueue<>(queueCapacity);
		this.recycledArrays = new ArrayBlockingQueue<>(nextPowerOfTwo(queueCapacity * 2));
	}
}
